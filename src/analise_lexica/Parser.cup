package analise_lexica;

import java_cup.runtime.*;
import java.util.*;
import java.io.*;


parser code {:
 	  
     public void report_error(String message, Object info) {
        StringBuilder m = new StringBuilder("Error ");

        if (info instanceof java_cup.runtime.Symbol) {
            m.append( "("+info.toString()+")" );
        }
        m.append(" : "+message);
        System.out.println(m);
    }
   
    public void report_fatal_error(String message, Object info) {
        report_error(message, info);
        throw new RuntimeException("Fatal Syntax Error");
    }

:};

/* Terminais */

terminal VAR, CONS;							// Variáveis e constantes
terminal INT, REAL, BOOL;					// Tipos Primitivos
terminal IF, THEN, ELSE, WHILE;				// If-Then-Else e While
terminal PROCEDURE, FUNCTION;				// Procedures e Functions
terminal COMMA, SEMICOLON;					// , E ;
terminal ATTRIB;							// :=
terminal LBRACK, RBRACK;                 	// [ E ]
terminal LBRACE, RBRACE;					// { E }
terminal LPAREN, RPAREN;					// ( E )
terminal TQ;								// |
terminal TRUE, FALSE;						// true e false

terminal PLUS, MINUS, MULT, DIV;			// +, -, *, /
terminal MOD, EQ, GTHAN, LTHAN;				// %, =, >, <
terminal NOT, AND, OR;						// not, and E or

terminal java.lang.Number INTEIRO, FLOAT;	// Inteiro e Float
terminal java.lang.String IDENTIFIER;		// Identificadores



/* Não-terminais */

non terminal program;
non terminal declaracoes, dec_list, dec_op;
non terminal var_decs, cons_decs, var_dec, var_cons_dec, var_dec_id, dec_proc, dec_func;
non terminal inicializador;
non terminal array_exts, array_ext, array_comp;
non terminal type, base_type, number;
non terminal parametros, parametro, parametro_type;
non terminal comando, comando_esp, bloco, bloco_com, bloco_comandos, bloco_comandos_list, assign;
non terminal expression, simples, bloco_exp, chamada, lista_exp, lista_exp2;


/* Precedências */

precedence right EQ;
precedence left GTHAN, LTHAN; 
precedence left PLUS, MINUS, OR; 
precedence left MULT, DIV, MOD, AND; 



/* Estrutura do programa */

start with program;


/* Programa pode ser uma lista de declarações de variáveis, constantes, procedimentos e funções */

program ::= declaracoes;

/*
*******************************************************************************************
*	dec_list -> produz uma lista de declarações. Pode ser vazio
*	dec_op -> produz as opções de declarações, que pode ser de variável (var_decs), constante (cons_decs), 
* procedimento (dec_proc) ou função (dec_func)
*******************************************************************************************
*/

declaracoes ::= | dec_list;
dec_list ::= dec_op | dec_list dec_op;
dec_op ::=  var_decs | cons_decs | dec_proc | dec_func;


/*
*******************************************************************************************
*	var_decs -> produz uma declaração de uma ou mais variáveis.
*	cons_decs -> produz uma declaração de uma ou mais constantes.
*******************************************************************************************
*/

var_decs ::= VAR type var_cons_dec SEMICOLON;
cons_decs ::= CONS type var_cons_dec SEMICOLON;

var_cons_dec ::=  var_dec | var_cons_dec COMMA var_dec;					// Gera uma ou mais variáveis/constantes separadas por vírgula

var_dec ::= var_dec_id ATTRIB inicializador;							// Gera a inicialização da variável/constante

var_dec_id ::= IDENTIFIER | var_dec_id LBRACK lista_exp RBRACK;

inicializador ::= expression | array_exts | array_comp;

array_exts ::= LBRACK array_ext RBRACK;
array_ext ::= array_ext COMMA expression;
array_comp ::= LBRACK IDENTIFIER TQ lista_exp RBRACK;

type ::= base_type | type LBRACK expression RBRACK;
base_type ::= number | BOOL;

number ::= INT | REAL;


dec_proc ::= PROCEDURE IDENTIFIER LPAREN parametros RPAREN comando;

dec_func ::= FUNCTION type IDENTIFIER LPAREN parametros RPAREN expression;

parametros ::= /* vazio */ | parametros COMMA parametro;
parametro ::= VAR parametro_type IDENTIFIER;
parametro_type ::= base_type | parametro_type LBRACK RBRACK;

comando ::= IF LPAREN expression RPAREN THEN comando
			| IF LPAREN expression RPAREN THEN comando_esp ELSE comando
			| WHILE LPAREN expression RPAREN comando
			| assign
			| chamada SEMICOLON
			| bloco;
			
comando_esp ::= IF LPAREN expression RPAREN THEN comando_esp ELSE comando_esp
					| WHILE LPAREN expression RPAREN comando_esp
					| assign
					| chamada SEMICOLON
					| bloco;
					
assign ::= IDENTIFIER EQ expression SEMICOLON;

bloco ::= LBRACE bloco_com RBRACE;
bloco_com ::= /* */ | bloco_comandos_list;
bloco_comandos_list ::= bloco_comandos | bloco_comandos_list bloco_comandos;
bloco_comandos ::= var_dec | cons_decs | comando;



expression ::= 	simples				
				| MINUS expression
				| IF LPAREN expression RPAREN THEN expression ELSE expression
				| expression PLUS expression
				| expression MINUS expression
				| expression MULT expression
				| expression DIV expression
				| expression MOD expression
				| expression EQ expression
				| expression GTHAN expression
				| expression LTHAN expression
				| NOT expression
				| expression AND expression
				| expression OR expression
				| bloco_exp; 

simples ::= INTEIRO | FLOAT | TRUE | FALSE

			| LPAREN expression RPAREN 
			| IDENTIFIER
			| IDENTIFIER LBRACK expression RBRACK
			| chamada;
			
chamada ::= IDENTIFIER LPAREN lista_exp RPAREN;

bloco_exp ::= LBRACE cons_decs expression RBRACE;



lista_exp ::= /* vazio */ | lista_exp2;
lista_exp2 ::= expression | lista_exp2 COMMA expression;

